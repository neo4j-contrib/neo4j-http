= Neo4j-HTTP
Michael Simons <michael.simons@neo4j.com>
:doctype: article
:lang: en
:listing-caption: Listing
:source-highlighter: coderay
:icons: font
// tag::properties[]
:groupId: org.neo4j
:artifactIdCore: neo4j-http
:branch: main
// end::properties[]

[abstract]
--
Neo4j-HTTP provides an HTTP API for Neo4j that runs externally to the core product and uses the https://github.com/neo4j/neo4j-java-driver[Neo4j Java Driver] exclusively for communicating with a database system.
--

== Main areas of work

Those are open topics:

- Create authenticator based on driver (when same password in basic auth as driver users, use that driver, otherwise create new instance and try to get a connection)
- Provide driver caching
- Per driver instance bookmark management
- Guestimator
- Use Jackson proper for formats
- Provide an option to run this as a Neo4j plugin similar to GDS Arrows (https://github.com/neo-technology/graph-analytics/blob/master/private/arrow/src/main/java/com/neo4j/gds/arrow/server/GdsFlightServerExtension.java)
- Bookmarkmanager (similar like SDN / Migrations or see if 5.x stuff is usable)


== Notes

Dependency management in separate, as boot comes with its own and the dependencies in the plugin and the api does not really overlap

=== Async or not

in general I am a fan of
https://spring.io/blog/2022/10/11/embracing-virtual-threads

> What we can say is that the most likely scenario in which you can benefit without almost any change, is if you’re currently not doing anything asynchronous at all (not even Servlet 3.1 style async requests, or otherwise you’ll probably need to make some revisions to align better). And of course, there would have to be some actual I/O or other thread parking for Loom to bring benefits.

but there is no loom yet

Couple of options:

* Create async controllers (just returning some variant of deferrable result)
** Use blocking api, wrap in completable futures, just use springs executors, will always thread swtich to netty
** Use async api, return completable futures, accept independence from driver io & spring
** Use async api, configure executors, will be really painful to call, but shared config

**Decision**

We went with the reactive variant… all async approaches are not ideal workarounds.

=== Running

==== With Aura env file

[source,console]
----
set -o allexport # <.>
(source ~/Downloads/credentials-xxx.env;  java -jar neo4j-http/target/neo4j-http-0.0.1-SNAPSHOT-runnable.jar)
set +o allexport
----
<.> Might not be needed in your shell

=== Streaming

requests must use the appropriate accept type

```
 echo "MATCH (n)  RETURN n" | http -a neo4j:secret localhost:8080/b  Accept:'application/x-ndjson' --stream
```

=== Supported complex types

Aligning with https://neo4j.com/docs/java-manual/current/cypher-workflow/#java-driver-type-mapping[Neo4j Java Driver types],
we support types that cannot and should not automatically get derived from a `String` by Jackson.
To use define those types in a request, the format `{"type": "TypeName", "value":"TypeValue"}` was chosen.

|===
|Type name | Java type | example value
| `LocalDate`       | `java.time.LocalDate`     | "2022-10-23"
| `OffsetTime`      | `java.time.OffsetTime`    | "13:37:11+02:00"
| `LocalTime`       | `java.time.LocalTime`     | "13:37:11"
| `ZonedDateTime`   | `java.time.ZonedDateTime` | "2022-10-18T13:37:11+02:00[Europe/Paris]"
| `LocalDateTime`   | `java.time.LocalDateTime` | "2022-10-18T13:37:11"
| `Duration`        | `java.time.Duration`      | "PT23H21M"
| `Period`          | `java.time.Period`        | "P20D"
| `Point`           | internal implementation of `org.neo4j.driver.types.Point` | "SRID=4979;POINT(12.994823 55.612191 2)"
| `Byte[]`          | `byte[]`                  | "00 01 02 03 04 05 06 07" (whitespaces are optional)
|===
